{
  "hash": "a6a24a7a83be5e5a29c6a3f4a5fe67fb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"COVID-19 Forecast: US Hospitalizations data\"\nlisting:\n  contents: posts/forecast_hosp\n  sort: \"date desc\"\n  type: default\n  categories: true\n  sort-ui: false\n  filter-ui: false\n  fields: [image, date, title, reading-time, description]\npage-layout: full\ntitle-block-banner: false\nimage: \"forecast.jpg\"\ndate: \"2024-07-03\"\ncategories: [R, API, Forecast, ARIMA model, Time series, Hospitalization, COVID-19]\ndescription: \"A overview of forecasting methods using US COVID-19 Hospitalization data throught API.\"\n\nexecute: \n  message: false\n  warning: false\n  \n  editor_options:\n    chunk_output_type: console\n    \nformat: \n  html:\n    code-fold: true\neditor: visual\n---\n\n\n\n# Request data using API in R\n\nAPIs allow programmers to request data directly from Server API or website through an Application Programming Interface. The first step is making a request to access the data in a certain website, the API server (own of data) will send back a response. There are several types of requests that one can make to an API server `GET, POST, PUT`. Four our purpose we'll be asking for data using `GET` requests.\n\nTo create a `GET` request we need to use the `GET()` function from the `httr` library.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\npacman::p_load(httr,            # request url using GET() function\n               jsonlite,        # convert JSON file to a data frame in R\n               forecast,        # fit sin and cosin terms to data\n               trending,        # fit and assess models\n               feasts,          # for time series decomposition and autocorrelation\n               janitor,         # summary table \n               tidyverse        # data management and visualization\n               )\n```\n:::\n\n\n\nLet's create an object called `path` that will be the JSON link. For particularly large datasets, you probably will not be able to grab all rows with a single API call. An alternative is to request the data in batches by using the`$limit`and `$offset` parameters. Users can request data beginning at a row other than the first row by specifying the `?$offset=_\" parameter` at the end of the URL. For example, for the COVID-19 Reported Patient Impact and Hospital Capacity by State Time Series dataset, `\"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000\" will bring in the first 50000 rows\"`, `\"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000&\\$offset=50000\"` will bring in the next 50000 rows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# url for first 50000 rows\npath <- \"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000\" \n\n# url for first 50000 rows\npath_2nd <- \"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000&$offset=50000\"\n```\n:::\n\n\n\nNow let's make the request using GET() function\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nrequest <- GET(url = path) \nrequest_2nd <- GET(url = path_2nd)\n```\n:::\n\n\n\n### Examining the GET() output\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# see the URL content\nrequest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nResponse [https://healthdata.gov/resource/g62h-syeh.json?$limit=50000]\n  Date: 2024-07-26 11:06\n  Status: 200\n  Content-Type: application/json;charset=utf-8\n  Size: 332 MB\n[{\"state\":\"MA\",\"date\":\"2021-06-15T00:00:00.000\",\"critical_staffing_shortage_t...\n,{\"state\":\"WY\",\"date\":\"2021-06-13T00:00:00.000\",\"critical_staffing_shortage_t...\n,{\"state\":\"LA\",\"date\":\"2021-06-06T00:00:00.000\",\"critical_staffing_shortage_t...\n,{\"state\":\"RI\",\"date\":\"2021-06-04T00:00:00.000\",\"critical_staffing_shortage_t...\n,{\"state\":\"KS\",\"date\":\"2021-06-03T00:00:00.000\",\"critical_staffing_shortage_t...\n,{\"state\":\"ME\",\"date\":\"2021-06-03T00:00:00.000\",\"critical_staffing_shortage_t...\n,{\"state\":\"RI\",\"date\":\"2021-06-02T00:00:00.000\",\"critical_staffing_shortage_t...\n,{\"state\":\"ME\",\"date\":\"2021-05-30T00:00:00.000\",\"critical_staffing_shortage_t...\n,{\"state\":\"RI\",\"date\":\"2021-05-30T00:00:00.000\",\"critical_staffing_shortage_t...\n,{\"state\":\"MS\",\"date\":\"2021-05-28T00:00:00.000\",\"critical_staffing_shortage_t...\n...\n```\n\n\n:::\n:::\n\n\n\nThe output shows: `Date: 2024-07-02 22:49` when the request was made `Status: 200` refers to the success or failure of the API request, if the number is 200 the request was successful. `Content-Type: application/json` the response says that the data takes on json format `Size: 332 MB` the size of the json file\n\n### Converting JSON file to a data frame\n\nJSON is formatted as a series of key-value pairs, where particular word (\"key\") is associated a particular value. to do this first let install jsonlite package that contain `fromJSON()` function that convert JSON file into `list`. The `fromJSON()` needs a character vector that contain the JSON structure.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Convert the raw Unicode into a character vector that resembles the JSON format\nconvert_JSON_to_df <- base::rawToChar(request$content)\n# Get the data we want in a format that we can more easily manipulate in R\nhospitalization_covid_usa <- fromJSON(convert_JSON_to_df, flatten = TRUE)\n\n######### convert the second file\n# Convert the raw Unicode into a character vector that resembles the JSON forma\nconvert_JSON_to_df_2nd <- base::rawToChar(request_2nd$content)\n# Get the data we want in a format that we can more easily manipulate in R\nhospitalization_covid_usa_2nd <- fromJSON(convert_JSON_to_df_2nd, flatten = TRUE)\n```\n:::\n\n\n\nLet's join the 2 tables using the `rbind()` function and clean the data. First I will clean the names of columns using the `clean_names()` function that standardizes the syntax of column names, and select interested variables. Use the `skim()` function for the summary table. I will select only 4 variables, `state`, `date`, `previous_day_admission_adult_covid_confirmed` and `previous_day_admission_pediatric_covid_confirmed`, the indicators are aligned to [WHO impatient care definition case](https://gateway.euro.who.int/en/indicators/hfa_534-6010-inpatient-care-discharges-per-100/#id=19629), then will sum give Hospitalization cases.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# join data frame using rbind\nhosp_clean <-rbind(hospitalization_covid_usa, hospitalization_covid_usa_2nd) %>%\n  clean_names() %>%\n  replace(is.na(.), 0) %>%\n  # calculate new hospitalization and deaths column\n  mutate(previous_day_admission_adult_covid_confirmed     = as.numeric(previous_day_admission_adult_covid_confirmed),\n         previous_day_admission_pediatric_covid_confirmed = as.numeric(previous_day_admission_pediatric_covid_confirmed),\n         new_hospitalization = previous_day_admission_adult_covid_confirmed + previous_day_admission_pediatric_covid_confirmed,\n         deaths_covid = as.numeric(deaths_covid),\n         date                = as.Date(date)) %>%\n  \n  # Select state, date and new_hospitalization variable\n  select(state, date, new_hospitalization, deaths_covid) %>%\n  \n  # create new variable \n  mutate(country  = \"UNITED STATES OF AMERICA\",\n          ISO_3_CODE = \"USA\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntm_clean <- hosp_clean%>%\n  mutate(yearmonth = zoo::as.yearmon(date)) %>%\n  group_by(yearmonth) %>%\n  summarise(new_hospitalization = sum(new_hospitalization, na.rm = TRUE),\n            deaths_covid = sum(deaths_covid, na.rm = TRUE))\n```\n:::\n\n\n\n# Time Series Forecasting\n\nIs about predicting the future events or values using historical and present data points. **Times Series:** is anything that is observers sequentially over time, data points are gathered over time.\n\nPredictor variables are often useful in time series forecasting. We have COVID-19 patient admission data in USA from `2020-01-01` to `2024-04-27`. In the next task we will continue of observations into the future using forecasting methods such as trend, seasonality and cyclic.\n\nThe basic step in a forecasting task is: - **Problem definition:** This requires an understanding of the way the forecasts will be used, who required the forecaster, and how the forecasting function fits within the requiring the forecasts - **Gathering information:** There are information required: statistical data and the accumulated expertise of people who collect the data and use the forecasts. - **Preliminary (exploratory) analysis:** Always start by graphing the data. Are there consistent patterns ? Is there a significant trend? Is seasonality important? various tools have been developed to help with this analysis. - **Choosing and fitting models:** The best model depends on the availability of historical data. - **Using and evaluating a forecasting model:** Once the model has been selected and its paremeters estimated, themodel is used to make forecasts.\n\n# Time series objects in R\n\nA time series can be throught of as vector or list of numbers. We store in a `ts` object, using `ts()` function\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntm<- ts(\n        tm_clean[, 2:3],        # Just take the sequence of values into column \n        start = c(2020,1),    # indicate the time of the first observation, c(year, period)\n        frequency = 12)       # is set to 12 because data are montlhy\n```\n:::\n\n\n\n# Time series plots \"Trend\"\n\nThis graphs ebable to visualize many features of data, including patterns, unusual observations, changes over time.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# message: false\nmax(hosp_clean$new_hospitalization)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2580\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nggplot2::autoplot(tm, facets = TRUE) +   \n  ggtitle(\"COVID-19: New Hospitalization - Deaths\")+\n  xlab(\"Year\")+\n  ylab(\"Number\")+\n  ylim(0,1000000)\n```\n\n::: {.cell-output-display}\n![Time serie of New Hospitalization and Deaths](forecast_files/figure-html/time_serie-1.png){width=672}\n:::\n:::\n\n\n\nThese time series, we have plotted, words such as \"trend\" and \"seasonal\" which need to be defined more carefully. -**Trend:** Exists when there is a long-term increase or decrease in the data. It does not have to be linear. -**Seasonal:**A seasonal pattern occurs when a time series is affected by seasonal factors such as the time of the year or the day of the week. Seasonality is always of a fixed and known frequency. -**Cyclic:** A cycle occurs when the data exhibit rises and falls that are not of a fixed frequency. These fluctuations are usually due to economic conditions, and are often related to the \"business cycle\". The duration of these fluctuations is usually at least 2 years.\n\nWe will use two more function `which.max()` and `frequency()` that can be used to identify the smallest index of the maximun value\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nwhich.max(tm[,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfrequency(tm[,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n\n## Polar Seasonal plot\n\nIs similar to a time plot except that the data are plotted against the individual \"seasons\" in which data were observed. will create using `ggseasonplot()` function\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code  code-fold=\"false\"}\n# polar seasonal plot for hospitalization\nggseasonplot(tm[,1], polar = TRUE) +\n  ylab(\"New Hospilatization\")+\n  ggtitle(\"Polar seasonal plot: New Hospitalization\")\n```\n\n::: {.cell-output-display}\n![-\"hospitalization\" -\"deaths\"](forecast_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# polar seasonal plot for deaths\nggseasonplot(tm[,2], polar = TRUE) +\n  ylab(\"New Hospilatization\")+\n  ggtitle(\"Polar seasonal plot: Deaths\")\n```\n\n::: {.cell-output-display}\n![-\"hospitalization\" -\"deaths\"](forecast_files/figure-html/unnamed-chunk-12-2.png){width=672}\n:::\n:::\n\n\n\n## Autocorrelation of non-seasonal time series\n\nAnother way to look at time series data is to plot each observation against another observation that occurred some time previously by using `gglagplot()`. For example, you could plot `Yt` against `Ytâˆ’1`. This is called a lag plot because you are plotting the time series against lags of itself.\n\nThe correlations associated with the lag plots form what is called the autocorrelation function (ACF). The `ggAcf()` function produces ACF plots.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# ACF plot of hospitalization data\nggAcf(tm[,2])\n```\n\n::: {.cell-output-display}\n![](forecast_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n###White noise\n\n-   iid, or random, independent, individually distributed observations\n\n###Ljung-Box Test\n\nThe Llung-Box test considers the first h autocorrelation values together\n\nA significant test (small p-value) indicates the data are probably not white noise.\n\n###White noise summary\n\n-   white noise is a time series that is purely random\n-   we can test for white noise by looking at an ACF plot or by doing a Ljung-Box test\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nBox.test(tm[,1], lag = 24, fitdf = 0, type = \"Ljung\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tBox-Ljung test\n\ndata:  tm[, 1]\nX-squared = 77.144, df = 24, p-value = 1.723e-07\n```\n\n\n:::\n:::\n\n\n\n# Difference series\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(diff(tm[,2])) \n```\n\n::: {.cell-output-display}\n![](forecast_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsummary(forecast::naive(tm[,1], h = 20))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nForecast method: Naive method\n\nModel Information:\nCall: forecast::naive(y = tm[, 1], h = 20) \n\nResidual sd: 98496.2732 \n\nError measures:\n                   ME     RMSE      MAE  MPE MAPE      MASE       ACF1\nTraining set 463.0588 98496.27 59888.31 -Inf  Inf 0.5476191 0.09158876\n\nForecasts:\n         Point Forecast     Lo 80    Hi 80     Lo 95    Hi 95\nMay 2024          24276 -101952.1 150504.1 -168773.1 217325.1\nJun 2024          24276 -154237.4 202789.4 -248736.7 297288.7\nJul 2024          24276 -194357.4 242909.4 -310094.9 358646.9\nAug 2024          24276 -228180.1 276732.1 -361822.3 410374.3\nSep 2024          24276 -257978.5 306530.5 -407395.0 455947.0\nOct 2024          24276 -284918.3 333470.3 -448595.9 497147.9\nNov 2024          24276 -309692.0 358244.0 -486484.0 535036.0\nDec 2024          24276 -332750.8 381302.8 -521749.4 570301.4\nJan 2025          24276 -354408.2 402960.2 -554871.4 603423.4\nFeb 2025          24276 -374892.2 423444.2 -586199.0 634751.0\nMar 2025          24276 -394375.1 442927.1 -615995.6 664547.6\nApr 2025          24276 -412990.8 461542.8 -644465.9 693017.9\nMay 2025          24276 -430845.7 479397.7 -671772.6 720324.6\nJun 2025          24276 -448026.1 496578.1 -698047.8 746599.8\nJul 2025          24276 -464603.1 513155.1 -723400.1 771952.1\nAug 2025          24276 -480636.2 529188.2 -747920.6 796472.6\nSep 2025          24276 -496175.6 544727.6 -771686.0 820238.0\nOct 2025          24276 -511264.3 559816.3 -794762.2 843314.2\nNov 2025          24276 -525939.3 574491.3 -817205.7 865757.7\nDec 2025          24276 -540233.0 588785.0 -839066.0 887618.0\n```\n\n\n:::\n:::\n\n\n\n## Checking time series residuals\n\nWhen applying a forecasting method, it is important to always check that the residual are well-behaved and resemble white noise.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntm[,1] %>% naive() %>% checkresiduals()\n```\n\n::: {.cell-output-display}\n![](forecast_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tLjung-Box test\n\ndata:  Residuals from Naive method\nQ* = 22.085, df = 10, p-value = 0.01468\n\nModel df: 0.   Total lags used: 10\n```\n\n\n:::\n:::\n\n\n\n# Forecasting with ARIMA models\n\nARIMA models aim to describe the autocorrelations in the data, use the `Arima()` function in R. There is another function `arima()` in T which also fits an ARIMA model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntm[,1] %>%\n  Arima(order = c (0,1,1), include.constant = FALSE) %>%\n  forecast() %>%\n  autoplot()\n```\n\n::: {.cell-output-display}\n![](forecast_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "forecast_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}