{"title":"COVID-19 Forecast: US Hospitalizations data","markdown":{"yaml":{"title":"COVID-19 Forecast: US Hospitalizations data","listing":{"contents":"posts/forecast_hosp","sort":"date desc","type":"default","categories":true,"sort-ui":false,"filter-ui":false,"fields":["image","date","title","reading-time","description"]},"page-layout":"full","title-block-banner":false,"image":"forecast.jpg","date":"2024-07-03","categories":["R","API","Forecast","ARIMA model","Time series","Hospitalization","COVID-19"],"description":"A overview of forecasting methods using US COVID-19 Hospitalization data throught API.","execute":{"message":false,"warning":false,"editor_options":{"chunk_output_type":"console"}},"format":{"html":{"code-fold":true}},"editor":"visual"},"headingText":"Request data using API in R","containsRefs":false,"markdown":"\n\n\nAPIs allow programmers to request data directly from Server API or website through an Application Programming Interface. The first step is making a request to access the data in a certain website, the API server (own of data) will send back a response. There are several types of requests that one can make to an API server `GET, POST, PUT`. Four our purpose we'll be asking for data using `GET` requests.\n\nTo create a `GET` request we need to use the `GET()` function from the `httr` library.\n\n```{r}\n#| label: httr_package\n#| code-fold: false\npacman::p_load(httr,            # request url using GET() function\n               jsonlite,        # convert JSON file to a data frame in R\n               forecast,        # fit sin and cosin terms to data\n               trending,        # fit and assess models\n               feasts,          # for time series decomposition and autocorrelation\n               janitor,         # summary table \n               tidyverse        # data management and visualization\n               )\n```\n\nLet's create an object called `path` that will be the JSON link. For particularly large datasets, you probably will not be able to grab all rows with a single API call. An alternative is to request the data in batches by using the`$limit`and `$offset` parameters. Users can request data beginning at a row other than the first row by specifying the `?$offset=_\" parameter` at the end of the URL. For example, for the COVID-19 Reported Patient Impact and Hospital Capacity by State Time Series dataset, `\"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000\" will bring in the first 50000 rows\"`, `\"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000&\\$offset=50000\"` will bring in the next 50000 rows.\n\n```{r}\n#| code-fold: false\n#| label: paths\n\n# url for first 50000 rows\npath <- \"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000\" \n\n# url for first 50000 rows\npath_2nd <- \"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000&$offset=50000\"\n```\n\nNow let's make the request using GET() function\n\n```{r}\n#| code-fold: false\nrequest <- GET(url = path) \nrequest_2nd <- GET(url = path_2nd)\n```\n\n### Examining the GET() output\n\n```{r}\n#| code-fold: false\n#| message: true\n\n# see the URL content\nrequest\n```\n\nThe output shows: `Date: 2024-07-02 22:49` when the request was made `Status: 200` refers to the success or failure of the API request, if the number is 200 the request was successful. `Content-Type: application/json` the response says that the data takes on json format `Size: 332 MB` the size of the json file\n\n### Converting JSON file to a data frame\n\nJSON is formatted as a series of key-value pairs, where particular word (\"key\") is associated a particular value. to do this first let install jsonlite package that contain `fromJSON()` function that convert JSON file into `list`. The `fromJSON()` needs a character vector that contain the JSON structure.\n\n```{r}\n#| code-fold: false\n# Convert the raw Unicode into a character vector that resembles the JSON format\nconvert_JSON_to_df <- base::rawToChar(request$content)\n# Get the data we want in a format that we can more easily manipulate in R\nhospitalization_covid_usa <- fromJSON(convert_JSON_to_df, flatten = TRUE)\n\n######### convert the second file\n# Convert the raw Unicode into a character vector that resembles the JSON forma\nconvert_JSON_to_df_2nd <- base::rawToChar(request_2nd$content)\n# Get the data we want in a format that we can more easily manipulate in R\nhospitalization_covid_usa_2nd <- fromJSON(convert_JSON_to_df_2nd, flatten = TRUE)\n\n```\n\nLet's join the 2 tables using the `rbind()` function and clean the data. First I will clean the names of columns using the `clean_names()` function that standardizes the syntax of column names, and select interested variables. Use the `skim()` function for the summary table. I will select only 4 variables, `state`, `date`, `previous_day_admission_adult_covid_confirmed` and `previous_day_admission_pediatric_covid_confirmed`, the indicators are aligned to [WHO impatient care definition case](https://gateway.euro.who.int/en/indicators/hfa_534-6010-inpatient-care-discharges-per-100/#id=19629), then will sum give Hospitalization cases.\n\n```{r}\n#| code-fold: false\n# join data frame using rbind\nhosp_clean <-rbind(hospitalization_covid_usa, hospitalization_covid_usa_2nd) %>%\n  clean_names() %>%\n  replace(is.na(.), 0) %>%\n  # calculate new hospitalization and deaths column\n  mutate(previous_day_admission_adult_covid_confirmed     = as.numeric(previous_day_admission_adult_covid_confirmed),\n         previous_day_admission_pediatric_covid_confirmed = as.numeric(previous_day_admission_pediatric_covid_confirmed),\n         new_hospitalization = previous_day_admission_adult_covid_confirmed + previous_day_admission_pediatric_covid_confirmed,\n         deaths_covid = as.numeric(deaths_covid),\n         date                = as.Date(date)) %>%\n  \n  # Select state, date and new_hospitalization variable\n  select(state, date, new_hospitalization, deaths_covid) %>%\n  \n  # create new variable \n  mutate(country  = \"UNITED STATES OF AMERICA\",\n          ISO_3_CODE = \"USA\")\n\n```\n\n```{r}\n#| label: summarized table\n#| code-fold: false\ntm_clean <- hosp_clean%>%\n  mutate(yearmonth = zoo::as.yearmon(date)) %>%\n  group_by(yearmonth) %>%\n  summarise(new_hospitalization = sum(new_hospitalization, na.rm = TRUE),\n            deaths_covid = sum(deaths_covid, na.rm = TRUE))\n\n```\n\n# Time Series Forecasting\n\nIs about predicting the future events or values using historical and present data points. **Times Series:** is anything that is observers sequentially over time, data points are gathered over time.\n\nPredictor variables are often useful in time series forecasting. We have COVID-19 patient admission data in USA from `2020-01-01` to `2024-04-27`. In the next task we will continue of observations into the future using forecasting methods such as trend, seasonality and cyclic.\n\nThe basic step in a forecasting task is: - **Problem definition:** This requires an understanding of the way the forecasts will be used, who required the forecaster, and how the forecasting function fits within the requiring the forecasts - **Gathering information:** There are information required: statistical data and the accumulated expertise of people who collect the data and use the forecasts. - **Preliminary (exploratory) analysis:** Always start by graphing the data. Are there consistent patterns ? Is there a significant trend? Is seasonality important? various tools have been developed to help with this analysis. - **Choosing and fitting models:** The best model depends on the availability of historical data. - **Using and evaluating a forecasting model:** Once the model has been selected and its paremeters estimated, themodel is used to make forecasts.\n\n# Time series objects in R\n\nA time series can be throught of as vector or list of numbers. We store in a `ts` object, using `ts()` function\n\n```{r}\n#| code-fold: false\ntm<- ts(\n        tm_clean[, 2:3],        # Just take the sequence of values into column \n        start = c(2020,1),    # indicate the time of the first observation, c(year, period)\n        frequency = 12)       # is set to 12 because data are montlhy\n\n```\n\n# Time series plots \"Trend\"\n\nThis graphs ebable to visualize many features of data, including patterns, unusual observations, changes over time.\n\n```{r}\n#| label: time_serie\n#| fig-cap: \"Time serie of New Hospitalization and Deaths\"\n#| code-fold: false\n# message: false\nmax(hosp_clean$new_hospitalization)\n\nggplot2::autoplot(tm, facets = TRUE) +   \n  ggtitle(\"COVID-19: New Hospitalization - Deaths\")+\n  xlab(\"Year\")+\n  ylab(\"Number\")+\n  ylim(0,1000000)\n```\n\nThese time series, we have plotted, words such as \"trend\" and \"seasonal\" which need to be defined more carefully. -**Trend:** Exists when there is a long-term increase or decrease in the data. It does not have to be linear. -**Seasonal:**A seasonal pattern occurs when a time series is affected by seasonal factors such as the time of the year or the day of the week. Seasonality is always of a fixed and known frequency. -**Cyclic:** A cycle occurs when the data exhibit rises and falls that are not of a fixed frequency. These fluctuations are usually due to economic conditions, and are often related to the \"business cycle\". The duration of these fluctuations is usually at least 2 years.\n\nWe will use two more function `which.max()` and `frequency()` that can be used to identify the smallest index of the maximun value\n\n```{r}\n#| code-fold: false\nwhich.max(tm[,2])\n```\n\n```{r}\n#| code-fold: false\nfrequency(tm[,2])\n```\n\n## Polar Seasonal plot\n\nIs similar to a time plot except that the data are plotted against the individual \"seasons\" in which data were observed. will create using `ggseasonplot()` function\n\n```{r}\n#| code-fold: false\n#| layout-ncol: 2\n#| fig-cap: \n#|   -\"hospitalization\"\n#|   -\"deaths\"\n\n# polar seasonal plot for hospitalization\nggseasonplot(tm[,1], polar = TRUE) +\n  ylab(\"New Hospilatization\")+\n  ggtitle(\"Polar seasonal plot: New Hospitalization\")\n\n# polar seasonal plot for deaths\nggseasonplot(tm[,2], polar = TRUE) +\n  ylab(\"New Hospilatization\")+\n  ggtitle(\"Polar seasonal plot: Deaths\")\n  \n```\n\n## Autocorrelation of non-seasonal time series\n\nAnother way to look at time series data is to plot each observation against another observation that occurred some time previously by using `gglagplot()`. For example, you could plot `Yt` against `Yt−1`. This is called a lag plot because you are plotting the time series against lags of itself.\n\nThe correlations associated with the lag plots form what is called the autocorrelation function (ACF). The `ggAcf()` function produces ACF plots.\n\n```{r}\n#| code-fold: false\n# ACF plot of hospitalization data\nggAcf(tm[,2])\n```\n\n###White noise\n\n-   iid, or random, independent, individually distributed observations\n\n###Ljung-Box Test\n\nThe Llung-Box test considers the first h autocorrelation values together\n\nA significant test (small p-value) indicates the data are probably not white noise.\n\n###White noise summary\n\n-   white noise is a time series that is purely random\n-   we can test for white noise by looking at an ACF plot or by doing a Ljung-Box test\n\n```{r}\n#| code-fold: false\n#| message: true\nBox.test(tm[,1], lag = 24, fitdf = 0, type = \"Ljung\")\n```\n\n# Difference series\n\n```{r}\nautoplot(diff(tm[,2])) \n```\n\n```{r}\n#| code-fold: false\n#| message: true\nsummary(forecast::naive(tm[,1], h = 20))\n```\n\n## Checking time series residuals\n\nWhen applying a forecasting method, it is important to always check that the residual are well-behaved and resemble white noise.\n\n```{r}\n#| code-fold: false\ntm[,1] %>% naive() %>% checkresiduals()\n```\n\n# Forecasting with ARIMA models\n\nARIMA models aim to describe the autocorrelations in the data, use the `Arima()` function in R. There is another function `arima()` in T which also fits an ARIMA model.\n\n```{r}\n#| code-fold: false\ntm[,1] %>%\n  Arima(order = c (0,1,1), include.constant = FALSE) %>%\n  forecast() %>%\n  autoplot()\n```\n","srcMarkdownNoYaml":"\n\n# Request data using API in R\n\nAPIs allow programmers to request data directly from Server API or website through an Application Programming Interface. The first step is making a request to access the data in a certain website, the API server (own of data) will send back a response. There are several types of requests that one can make to an API server `GET, POST, PUT`. Four our purpose we'll be asking for data using `GET` requests.\n\nTo create a `GET` request we need to use the `GET()` function from the `httr` library.\n\n```{r}\n#| label: httr_package\n#| code-fold: false\npacman::p_load(httr,            # request url using GET() function\n               jsonlite,        # convert JSON file to a data frame in R\n               forecast,        # fit sin and cosin terms to data\n               trending,        # fit and assess models\n               feasts,          # for time series decomposition and autocorrelation\n               janitor,         # summary table \n               tidyverse        # data management and visualization\n               )\n```\n\nLet's create an object called `path` that will be the JSON link. For particularly large datasets, you probably will not be able to grab all rows with a single API call. An alternative is to request the data in batches by using the`$limit`and `$offset` parameters. Users can request data beginning at a row other than the first row by specifying the `?$offset=_\" parameter` at the end of the URL. For example, for the COVID-19 Reported Patient Impact and Hospital Capacity by State Time Series dataset, `\"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000\" will bring in the first 50000 rows\"`, `\"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000&\\$offset=50000\"` will bring in the next 50000 rows.\n\n```{r}\n#| code-fold: false\n#| label: paths\n\n# url for first 50000 rows\npath <- \"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000\" \n\n# url for first 50000 rows\npath_2nd <- \"https://healthdata.gov/resource/g62h-syeh.json?$limit=50000&$offset=50000\"\n```\n\nNow let's make the request using GET() function\n\n```{r}\n#| code-fold: false\nrequest <- GET(url = path) \nrequest_2nd <- GET(url = path_2nd)\n```\n\n### Examining the GET() output\n\n```{r}\n#| code-fold: false\n#| message: true\n\n# see the URL content\nrequest\n```\n\nThe output shows: `Date: 2024-07-02 22:49` when the request was made `Status: 200` refers to the success or failure of the API request, if the number is 200 the request was successful. `Content-Type: application/json` the response says that the data takes on json format `Size: 332 MB` the size of the json file\n\n### Converting JSON file to a data frame\n\nJSON is formatted as a series of key-value pairs, where particular word (\"key\") is associated a particular value. to do this first let install jsonlite package that contain `fromJSON()` function that convert JSON file into `list`. The `fromJSON()` needs a character vector that contain the JSON structure.\n\n```{r}\n#| code-fold: false\n# Convert the raw Unicode into a character vector that resembles the JSON format\nconvert_JSON_to_df <- base::rawToChar(request$content)\n# Get the data we want in a format that we can more easily manipulate in R\nhospitalization_covid_usa <- fromJSON(convert_JSON_to_df, flatten = TRUE)\n\n######### convert the second file\n# Convert the raw Unicode into a character vector that resembles the JSON forma\nconvert_JSON_to_df_2nd <- base::rawToChar(request_2nd$content)\n# Get the data we want in a format that we can more easily manipulate in R\nhospitalization_covid_usa_2nd <- fromJSON(convert_JSON_to_df_2nd, flatten = TRUE)\n\n```\n\nLet's join the 2 tables using the `rbind()` function and clean the data. First I will clean the names of columns using the `clean_names()` function that standardizes the syntax of column names, and select interested variables. Use the `skim()` function for the summary table. I will select only 4 variables, `state`, `date`, `previous_day_admission_adult_covid_confirmed` and `previous_day_admission_pediatric_covid_confirmed`, the indicators are aligned to [WHO impatient care definition case](https://gateway.euro.who.int/en/indicators/hfa_534-6010-inpatient-care-discharges-per-100/#id=19629), then will sum give Hospitalization cases.\n\n```{r}\n#| code-fold: false\n# join data frame using rbind\nhosp_clean <-rbind(hospitalization_covid_usa, hospitalization_covid_usa_2nd) %>%\n  clean_names() %>%\n  replace(is.na(.), 0) %>%\n  # calculate new hospitalization and deaths column\n  mutate(previous_day_admission_adult_covid_confirmed     = as.numeric(previous_day_admission_adult_covid_confirmed),\n         previous_day_admission_pediatric_covid_confirmed = as.numeric(previous_day_admission_pediatric_covid_confirmed),\n         new_hospitalization = previous_day_admission_adult_covid_confirmed + previous_day_admission_pediatric_covid_confirmed,\n         deaths_covid = as.numeric(deaths_covid),\n         date                = as.Date(date)) %>%\n  \n  # Select state, date and new_hospitalization variable\n  select(state, date, new_hospitalization, deaths_covid) %>%\n  \n  # create new variable \n  mutate(country  = \"UNITED STATES OF AMERICA\",\n          ISO_3_CODE = \"USA\")\n\n```\n\n```{r}\n#| label: summarized table\n#| code-fold: false\ntm_clean <- hosp_clean%>%\n  mutate(yearmonth = zoo::as.yearmon(date)) %>%\n  group_by(yearmonth) %>%\n  summarise(new_hospitalization = sum(new_hospitalization, na.rm = TRUE),\n            deaths_covid = sum(deaths_covid, na.rm = TRUE))\n\n```\n\n# Time Series Forecasting\n\nIs about predicting the future events or values using historical and present data points. **Times Series:** is anything that is observers sequentially over time, data points are gathered over time.\n\nPredictor variables are often useful in time series forecasting. We have COVID-19 patient admission data in USA from `2020-01-01` to `2024-04-27`. In the next task we will continue of observations into the future using forecasting methods such as trend, seasonality and cyclic.\n\nThe basic step in a forecasting task is: - **Problem definition:** This requires an understanding of the way the forecasts will be used, who required the forecaster, and how the forecasting function fits within the requiring the forecasts - **Gathering information:** There are information required: statistical data and the accumulated expertise of people who collect the data and use the forecasts. - **Preliminary (exploratory) analysis:** Always start by graphing the data. Are there consistent patterns ? Is there a significant trend? Is seasonality important? various tools have been developed to help with this analysis. - **Choosing and fitting models:** The best model depends on the availability of historical data. - **Using and evaluating a forecasting model:** Once the model has been selected and its paremeters estimated, themodel is used to make forecasts.\n\n# Time series objects in R\n\nA time series can be throught of as vector or list of numbers. We store in a `ts` object, using `ts()` function\n\n```{r}\n#| code-fold: false\ntm<- ts(\n        tm_clean[, 2:3],        # Just take the sequence of values into column \n        start = c(2020,1),    # indicate the time of the first observation, c(year, period)\n        frequency = 12)       # is set to 12 because data are montlhy\n\n```\n\n# Time series plots \"Trend\"\n\nThis graphs ebable to visualize many features of data, including patterns, unusual observations, changes over time.\n\n```{r}\n#| label: time_serie\n#| fig-cap: \"Time serie of New Hospitalization and Deaths\"\n#| code-fold: false\n# message: false\nmax(hosp_clean$new_hospitalization)\n\nggplot2::autoplot(tm, facets = TRUE) +   \n  ggtitle(\"COVID-19: New Hospitalization - Deaths\")+\n  xlab(\"Year\")+\n  ylab(\"Number\")+\n  ylim(0,1000000)\n```\n\nThese time series, we have plotted, words such as \"trend\" and \"seasonal\" which need to be defined more carefully. -**Trend:** Exists when there is a long-term increase or decrease in the data. It does not have to be linear. -**Seasonal:**A seasonal pattern occurs when a time series is affected by seasonal factors such as the time of the year or the day of the week. Seasonality is always of a fixed and known frequency. -**Cyclic:** A cycle occurs when the data exhibit rises and falls that are not of a fixed frequency. These fluctuations are usually due to economic conditions, and are often related to the \"business cycle\". The duration of these fluctuations is usually at least 2 years.\n\nWe will use two more function `which.max()` and `frequency()` that can be used to identify the smallest index of the maximun value\n\n```{r}\n#| code-fold: false\nwhich.max(tm[,2])\n```\n\n```{r}\n#| code-fold: false\nfrequency(tm[,2])\n```\n\n## Polar Seasonal plot\n\nIs similar to a time plot except that the data are plotted against the individual \"seasons\" in which data were observed. will create using `ggseasonplot()` function\n\n```{r}\n#| code-fold: false\n#| layout-ncol: 2\n#| fig-cap: \n#|   -\"hospitalization\"\n#|   -\"deaths\"\n\n# polar seasonal plot for hospitalization\nggseasonplot(tm[,1], polar = TRUE) +\n  ylab(\"New Hospilatization\")+\n  ggtitle(\"Polar seasonal plot: New Hospitalization\")\n\n# polar seasonal plot for deaths\nggseasonplot(tm[,2], polar = TRUE) +\n  ylab(\"New Hospilatization\")+\n  ggtitle(\"Polar seasonal plot: Deaths\")\n  \n```\n\n## Autocorrelation of non-seasonal time series\n\nAnother way to look at time series data is to plot each observation against another observation that occurred some time previously by using `gglagplot()`. For example, you could plot `Yt` against `Yt−1`. This is called a lag plot because you are plotting the time series against lags of itself.\n\nThe correlations associated with the lag plots form what is called the autocorrelation function (ACF). The `ggAcf()` function produces ACF plots.\n\n```{r}\n#| code-fold: false\n# ACF plot of hospitalization data\nggAcf(tm[,2])\n```\n\n###White noise\n\n-   iid, or random, independent, individually distributed observations\n\n###Ljung-Box Test\n\nThe Llung-Box test considers the first h autocorrelation values together\n\nA significant test (small p-value) indicates the data are probably not white noise.\n\n###White noise summary\n\n-   white noise is a time series that is purely random\n-   we can test for white noise by looking at an ACF plot or by doing a Ljung-Box test\n\n```{r}\n#| code-fold: false\n#| message: true\nBox.test(tm[,1], lag = 24, fitdf = 0, type = \"Ljung\")\n```\n\n# Difference series\n\n```{r}\nautoplot(diff(tm[,2])) \n```\n\n```{r}\n#| code-fold: false\n#| message: true\nsummary(forecast::naive(tm[,1], h = 20))\n```\n\n## Checking time series residuals\n\nWhen applying a forecasting method, it is important to always check that the residual are well-behaved and resemble white noise.\n\n```{r}\n#| code-fold: false\ntm[,1] %>% naive() %>% checkresiduals()\n```\n\n# Forecasting with ARIMA models\n\nARIMA models aim to describe the autocorrelations in the data, use the `Arima()` function in R. There is another function `arima()` in T which also fits an ARIMA model.\n\n```{r}\n#| code-fold: false\ntm[,1] %>%\n  Arima(order = c (0,1,1), include.constant = FALSE) %>%\n  forecast() %>%\n  autoplot()\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"editor_options":{"chunk_output_type":"console"},"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["shinylive"],"css":["../../styles.css"],"toc":true,"toc-depth":3,"include-after-body":["../../body_footer.html"],"output-file":"forecast.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.53","static-dir":"../../data","google-analytics":"G-30NH2GNE6G","cookie-consent":true,"twitter-card":true,"extensions":["quarto-ext/shinylive"],"theme":"flatly","resources":["DummyApp"],"title-block-banner":false,"author":"João Muianga","page-layout":"full","comments":{"utterances":{"repo":"joaomuianga/myblog"}},"pdf":{"toc":true},"title":"COVID-19 Forecast: US Hospitalizations data","listing":{"contents":"posts/forecast_hosp","sort":"date desc","type":"default","categories":true,"sort-ui":false,"filter-ui":false,"fields":["image","date","title","reading-time","description"]},"image":"forecast.jpg","date":"2024-07-03","categories":["R","API","Forecast","ARIMA model","Time series","Hospitalization","COVID-19"],"description":"A overview of forecasting methods using US COVID-19 Hospitalization data throught API.","editor":"visual"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}